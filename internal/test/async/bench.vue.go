// Code generated by go-vue-ssr: https://github.com/zbysir/go-vue-ssr
// src_hash:1d768bf541d8155ccea0ceb89de5d279

package async

import (
	"strings"
)

type _ strings.Builder

func (r *Render) Component_bench2(options *Options) *PromiseGroup {
	scope := extendScope(r.Global.Scope, options.Props)
	options.Directives.Exec(r, options)
	_ = scope

	g := &PromiseGroup{}

	g.Append(r.tag("div", true, &Options{
		PropsClass: map[string]interface{}{"a": true,},
		Class: []string{"b", },
		Slots: map[string]NamedSlotFunc{"default": func(props Props) *PromiseGroup{g:=&PromiseGroup{} ;g.Append("<span"+mixinClass(nil, []string{"d"}, map[string]interface{}{"c": true,})+mixinAttr(nil, nil, map[string]interface{}{"a": 1,})+">")
			g.Append(interfaceToStr(scope.Get("data", "msg")))
			g.Append("</span>")
			func ()*PromiseGroup{
				if interfaceToBool(scope.Get("a")) { g.Append("<div"+""+">")

					g.Append("</div>")} else {
					for index, item := range interface2Slice(scope.Get("a")) {
						g.AppendGroup(func(xscope *Scope) *PromiseGroup{
							scope := extendScope(xscope, map[string]interface{}{
								"$index": index,
								"id": item,
							})
							_ = scope
							g:=&PromiseGroup{}
							g.Append("<div"+""+">")

							g.Append("</div>")

							return g
						}(scope))
					}

				}
				return nil
			}()

			for index, item := range interface2Slice(scope.Get("data", "c")) {
				g.AppendGroup(func(xscope *Scope) *PromiseGroup{
					scope := extendScope(xscope, map[string]interface{}{
						"$index": index,
						"item": item,
					})
					_ = scope
					g:=&PromiseGroup{}
					g.Append("<div"+""+">")
					g.Append(r.Component_async(&Options{
						Slots: map[string]NamedSlotFunc{"default": func(props Props) *PromiseGroup{g:=&PromiseGroup{} ;g.Append("<bench"+mixinAttr(nil, nil, map[string]interface{}{"data": scope.Get("item"),})+">")

							g.Append("</bench>")
							;return g},},
						P: options,
						Scope: scope,
					}))

					g.Append("</div>")
					return g
				}(scope))
			}

			;return g},},
		P: options,
		Scope: scope,
	}))
	return g
}
func (r *Render) Component_bench(options *Options) *PromiseGroup {
	scope := extendScope(r.Global.Scope, options.Props)
	options.Directives.Exec(r, options)
	_ = scope
	var g = r.tag("div", true, &Options{
		PropsClass: map[string]interface{}{"a": true},
		Class:      []string{"b"},
		Slots: map[string]NamedSlotFunc{"default": func(props Props) *PromiseGroup {
			var g = &PromiseGroup{
				Note: "div-slots",
			}
			g.Append(PromiseString("<span" + mixinClass(nil, []string{"d"}, map[string]interface{}{"c": true}) + mixinAttr(nil, nil, map[string]interface{}{"a": 1}) + ">\n        " + interfaceToStr(scope.Get("data", "msg"), true) + "\n    </span>"))
			g.AppendGroup(r.Component_async(&Options{
				Slots: map[string]NamedSlotFunc{"default": func(props Props) *PromiseGroup {
					var b = &PromiseGroup{
						Note: "async-slots",
					}

					for index, item := range interface2Slice(scope.Get("data", "c")) {
						b.AppendGroup(func(xscope *Scope) *PromiseGroup {
							scope := extendScope(xscope, map[string]interface{}{
								"$index": index,
								"item":   item,
							})

							var g = &PromiseGroup{
								Note: "for-slot",
							}
							g.Append(PromiseString("<div>"))
							g.AppendGroup(r.Component_bench(&Options{
								Props: map[string]interface{}{"data": scope.Get("item")},
								Slots: map[string]NamedSlotFunc{},
								P:     options,
								Scope: scope,
							}))

							g.Append(PromiseString("</div>"))
							return g
						}(scope))
					}

					return b

				}},
				P:     options,
				Scope: scope,
			}))

			return g
		}},
		P:     options,
		Scope: scope,
	})
	return g
}
