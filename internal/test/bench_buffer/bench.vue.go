// Code generated by go-vue-ssr: https://github.com/zbysir/go-vue-ssr
// src_hash:a336d472441d7e80aea1de88176841ec

package bench_buffer

import (
	"strings"
)

type _ strings.Builder

func (r *Render) Component_bench(w Writer, options *Options) {
	scope := extendScope(r.Global.Scope, options.Props)
	options.Directives.Exec(r, options)
	_ = scope
	r.tag(w, "div", true, &Options{
		PropsClass: map[string]interface{}{"a": true},
		Class:      []string{"b"},
		Slots: map[string]NamedSlotFunc{"default": func(w Writer, props Props) {
			w.WriteString("<span" + mixinClass(nil, []string{"d"}, map[string]interface{}{"c": true}) + mixinAttr(nil, nil, map[string]interface{}{"a": 1}) + ">\n        " + interfaceToStr(scope.Get("data", "msg"), true) + "\n    </span>")

			for index, item := range interface2Slice(scope.Get("data", "c")) {
				func(xscope *Scope) {
					scope := extendScope(xscope, map[string]interface{}{
						"$index": index,
						"item":   item,
					})
					_ = scope
					w.WriteString("<div>")
					r.Component_bench(w, &Options{
						Props: map[string]interface{}{"data": scope.Get("item")},
						Slots: map[string]NamedSlotFunc{"default": func(w Writer, props Props) {

						}},
						P:     options,
						Scope: scope,
					})
					w.WriteString("</div>")
				}(scope)
			}

		}},
		P:     options,
		Scope: scope,
	})
	return
}
