对比了用字符串评价和buffer的方式的性能, 结果如下

基于字符串拼接实现 在线性for循环的场景下: 

|循环次数|ns/op|
|----|----|
|100|870,556|
|1000|10,105,247|
|10000|110,299,760|

在递归的场景下:

|递归深度|ns/op|
|----|----|
|100|2,268,346|
|1000|151,428,086|
|10000|15,579,999,800|

基于strings.builder实现

在线性for循环的场景下: 

|循环次数|ns/op|
|----|----|
|100|839,999|
|1000|9,474,573|
|10000|97,250,017|

在递归的场景下:

|递归深度|ns/op|
|----|----|
|100|905,501|
|1000|13,238,065|
|10000|152,000,229|

### 结论
在for场景下, 性能提升并不明显.

性能差别在递归场景下才会体现, 推测是由于嵌套调用次数很深 函数调用返回的string太长, 这时候使用字符串拼接和buffer之间的
性能差异才会被体现出来.

通过简单的代码查看内存占用和GC次数, 我们也会发现 使用字符串拼接的模式会导致很多GC.
```
var m runtime.MemStats
runtime.ReadMemStats(&m)
kb := 1024.0
logstr := fmt.Sprintf("\nAlloc = %v\tTotalAlloc = %v\tSys = %v\t NumGC = %v\n\n", float64(m.Alloc)/kb, float64(m.TotalAlloc)/kb, float64(m.Sys)/kb, m.NumGC)
t.Log(logstr)
```

这是使用strings.builder嵌套 1000次运行后的结果
```
Alloc = 2138.0078125	TotalAlloc = 3934.1640625	Sys = 10822.4921875	 NumGC = 1
```

这是字符串拼接
```
Alloc = 8654.1171875	TotalAlloc = 235710.8984375	Sys = 24082.8671875	 NumGC = 51
```
